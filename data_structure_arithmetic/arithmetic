####时间复杂度
a*O(n^2)    和常数a关系不大， 主要看n, 表示算法执行的最低上界

n一样的情况下
O(nlogn + n) = O(nlogn)
O(nlogn + n^2) = O(n^2)


O(1)    最低的时间复杂度
不论数据量n的大小 都可以一次查找到目标 例如hash

O(n)    
数据量n增加多少 复杂度就增加多少，例如一次遍历

O(logn)
数据量n增加多少 复杂度就增加logn倍
log以2为底，例如n=256 logn = 8
二分查找，每次找到后排除一半的可能性

O(nlogn)
数据量n增加多少 复杂度就增加nlogn倍 归并排序 快速排序

O(n2)
数据量n增加多少 复杂度就增加对应的平方倍 比如冒泡排序,插入排序,选择排序


####一个字符串数组，将数组中的每一个字符串按照字母顺序排序；之后再将整个字符串按照字典序排序；整个操作的时间复杂度是多少

假设最长的字符串长度s   数组中有n个字符串
对每个字符串排序    O(slog(s))      每个字母长度是1
n字符串排序    O(n * slog(s))
将整个字符串数组按照字典序排序  O(s*nlog(n))    最长字符长度是s
最后    O(n * s log(s)) + O(s * nlog(n)) = O(n * s * (log(s) + log(n)))




O(n)的算法大约可以在1s内处理10^7的数据
logaN = logab * logbN


####空间复杂度
多开一个辅助的数组      O(n)
多开一个辅助的二维数组  O(n^2)
多开常数空间(变量)            O(1)

递归函数会增加空间复杂度代价


